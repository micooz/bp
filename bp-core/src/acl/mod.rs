use std::{
    fmt::Display,
    fs,
    io::Write,
    path::PathBuf,
    sync::{self, Arc},
    time,
};

use anyhow::{Error, Result};
use notify::{RecommendedWatcher, RecursiveMode, Watcher};
use parking_lot::Mutex;

use crate::global;

pub fn get_acl() -> Arc<AccessControlList> {
    global::get_acl()
}

// AccessControlList

#[derive(Default, Debug)]
pub struct AccessControlList {
    rules: Mutex<Vec<Rule>>,
}

impl AccessControlList {
    pub fn load_from_file(&self, path: &str) -> Result<()> {
        if path.is_empty() {
            return Err(Error::msg("empty string specified"));
        }

        log::info!("loading white list from {}", path);

        let mut content = String::new();
        fs::read_to_string(&mut content).unwrap();

        self.clear();
        self.deserialize(&content);

        log::info!("loaded {} valid rules", self.count());

        Ok(())
    }

    pub fn save_to_file(&self, path: PathBuf) -> Result<()> {
        let mut file = fs::OpenOptions::new().write(true).create(true).open(path)?;

        let buf = self.serialize();

        file.write_all(buf.as_bytes())?;
        file.flush()?;

        Ok(())
    }

    pub fn push<V>(&self, prefix: RulePrefix, value: V)
    where
        V: Into<RuleValue> + Display,
    {
        self.rules.lock().insert(
            0,
            Rule {
                raw: format!("{}{}", prefix, value),
                prefix,
                value: value.into(),
            },
        );
    }

    pub fn match_one(&self, host: &str, port: u16) -> Rule {
        //
    }

    pub fn is_host_hit(&self, host: &str) -> bool {
        let domain_white_list = self.rules.lock();

        for item in domain_white_list.iter() {
            match item.rule {
                DomainRule::ExactMatch => {
                    if item.value == host {
                        return true;
                    }
                }
                DomainRule::NotExtractMatch => {
                    if item.value == host {
                        return false;
                    }
                }
                DomainRule::FuzzyMatch => {
                    if host.contains(&item.value) {
                        return true;
                    }
                }
                DomainRule::Ignore => {}
            }
        }

        false
    }

    pub fn watch(&self, path: &str) -> notify::Result<()> {
        // Create a channel to receive the events.
        let (tx, rx) = sync::mpsc::channel();

        // Automatically select the best implementation for your platform.
        // You can also access each implementation directly e.g. INotifyWatcher.
        let mut watcher: RecommendedWatcher = Watcher::new(tx, time::Duration::from_secs(2))?;

        // Add a path to be watched. All files and directories at that path and
        // below will be monitored for changes.
        watcher.watch(&path, RecursiveMode::NonRecursive)?;

        // This is a simple loop, but you may want to use more complex logic here,
        // for example to handle I/O.
        loop {
            if let Ok(notify::DebouncedEvent::Write(_)) = rx.recv() {
                if let Err(res) = self.load_from_file(path) {
                    log::warn!("reload failed due to: {}", res.to_string())
                }
            }
        }
    }

    pub fn count(&self) -> usize {
        self.rules
            .lock()
            .iter()
            .filter(|&x| x.prefix != RulePrefix::Ignore)
            .count()
    }

    pub fn to_pac(&self, proxy_addr: &str) -> String {
        let mut if_statements: Vec<String> = vec![];

        for item in self.rules.lock().iter() {
            let rule = match item.rule {
                DomainRule::ExactMatch => {
                    format!(
                        "if (shExpMatch(host, \"{}\")) return \"PROXY {}\";",
                        item.value, proxy_addr
                    )
                }
                DomainRule::FuzzyMatch => {
                    format!(
                        "if (shExpMatch(host, \"*{}*\")) return \"PROXY {}\";",
                        item.value, proxy_addr
                    )
                }
                DomainRule::NotExtractMatch => {
                    format!("if (shExpMatch(host, \"{}\")) return \"DIRECT\";", item.value)
                }
                DomainRule::Ignore => {
                    format!("// skip {}", item.value)
                }
            };
            if_statements.push(format!("  {}", rule));
        }

        let tips = "// This file is automatically generated.\n\n";

        format!(
            "{}function FindProxyForURL(url, host) {{\n{}\n\n  return \"DIRECT\";\n}}\n",
            tips,
            if_statements.join("\n")
        )
    }

    fn clear(&self) {
        self.rules.lock().clear();
    }

    fn deserialize(&self, content: &str) {
        let mut rules = self.rules.lock();

        for line in content.lines() {
            let line = line.trim();

            let found = rules
                .iter()
                .enumerate()
                .find_map(|(index, v)| if v.raw == line { Some(index) } else { None });

            if let Some(index) = found {
                rules.remove(index);
            }

            let mut chars = line.trim().chars();
            let mut first_char = None;

            let rule = match chars.next() {
                Some(ch) => match ch {
                    '~' => DomainRule::FuzzyMatch,
                    '#' => DomainRule::Ignore,
                    '!' => DomainRule::NotExtractMatch,
                    _ => {
                        first_char = Some(ch);
                        DomainRule::ExactMatch
                    }
                },
                None => continue,
            };

            let mut value = chars.collect::<String>();

            if let Some(ch) = first_char {
                value.insert(0, ch);
            }

            rules.push(DomainItem {
                raw: line.to_string(),
                rule,
                value,
            });
        }

        rules.reverse();
    }

    fn serialize(&self) -> String {
        self.rules
            .lock()
            .iter()
            .rev()
            .map(|x| x.raw)
            .collect::<Vec<String>>()
            .join("\n")
    }
}

// Rule

#[derive(Default, Debug, PartialEq, Eq)]
pub struct Rule {
    raw: String,
    prefix: RulePrefix,
    value: RuleValue,
}

// RuleValue

#[derive(Default, Debug, PartialEq, Eq)]
pub struct RuleValue {
    host: String,
    port: u16,
}

// RulePrefix

#[derive(Debug, PartialEq, Eq)]
pub enum RulePrefix {
    Exact,
    Fuzzy,
    Ignore,
}

impl Display for RulePrefix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let v = match self {
            Self::Exact => "",
            Self::Fuzzy => "~",
            Self::Ignore => "#",
        };
        write!(f, "{}", v)
    }
}

impl Default for RulePrefix {
    fn default() -> Self {
        Self::Ignore
    }
}
