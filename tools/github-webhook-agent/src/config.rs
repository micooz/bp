use crate::constants::{TEMP_DIR, TEMP_SCRIPT_PATH};
use crate::context::Context;
use crate::utils::template::Template;
use crate::utils::yaml_checker::YamlChecker;
use anyhow::{Error, Result};
use cmd_lib::{run_cmd, run_fun};
use serde_json::{Map, Value};
use std::fs;
use std::io::Read;
use std::io::Write;
use std::path::Path;
use vial::Request;
use yaml_rust::Yaml;
use yaml_rust::YamlLoader;

pub struct Config {
    rules: Vec<Rule>,
}

impl Config {
    pub fn from_file<P>(file: P) -> Result<Self>
    where
        P: AsRef<Path>,
    {
        let mut yaml_file = fs::OpenOptions::new().read(true).open(file)?;
        let mut yaml_content = String::new();

        yaml_file.read_to_string(&mut yaml_content)?;

        let doc = &YamlLoader::load_from_str(yaml_content.as_str()).unwrap()[0];
        let doc = doc.as_hash().ok_or_else(|| Error::msg("invalid yaml format"))?;

        let mut rules = vec![];

        for item in doc.values() {
            let rule = Rule::from_yaml_doc(item.clone()).map_err(|_| Error::msg("invalid yaml format"))?;
            rules.push(rule);
        }

        Ok(Self { rules })
    }

    pub fn try_match(&self, req: &Request, body: &Value) -> Option<&Rule> {
        for rule in &self.rules {
            if rule.try_match(req, body).is_ok() {
                return Some(rule);
            }
        }
        None
    }
}

pub struct Rule {
    matcher: Option<Matcher>,
    run: Option<String>,
}

impl Rule {
    pub fn from_yaml_doc(doc: Yaml) -> Result<Self, ()> {
        let root = doc.as_hash().ok_or(())?;

        let key_match = Yaml::String("match".to_string());
        let key_header = Yaml::String("header".to_string());
        let key_body = Yaml::String("body".to_string());
        let key_run = Yaml::String("run".to_string());

        // get "match: xxx"
        let matcher = root.get(&key_match).map(|v| v.as_hash().unwrap());

        let mut matcher_optional = None;

        if let Some(matcher) = matcher {
            let matcher_header = matcher.get(&key_header);
            let matcher_body = matcher.get(&key_body);

            matcher_optional = Some(Matcher {
                header: matcher_header.cloned(),
                body: matcher_body.cloned(),
            });
        }

        // get "run: xxx"
        let run = root.get(&key_run).map(|v| v.as_str().unwrap().to_string());

        Ok(Rule {
            matcher: matcher_optional,
            run,
        })
    }

    pub fn try_match(&self, req: &Request, body: &Value) -> Result<(), ()> {
        let checker = YamlChecker::new();

        if self.matcher.is_none() {
            return Ok(());
        }

        let matcher = self.matcher.as_ref().unwrap();

        // match header
        if let Some(header_yaml) = &matcher.header {
            let header_map = header_yaml.as_hash().unwrap();
            let mut header = Map::new();

            for (key, _) in header_map {
                let key = key.as_str().ok_or(())?;
                let val = req.header(key).ok_or(())?;

                header.insert(key.to_string(), Value::String(val.to_string()));
            }

            let header_json = Value::Object(header);

            if !checker.check_json(header_yaml, &header_json) {
                return Err(());
            }
        }

        // match body
        if let Some(body_yaml) = &matcher.body {
            if !checker.check_json(body_yaml, body) {
                return Err(());
            }
        }

        Ok(())
    }

    pub fn run(&self, ctx: Context) -> Result<String> {
        let cmd_list = self.compile_run_str(ctx)?;

        run_cmd!(mkdir -p $TEMP_DIR)?;

        let mut sh = fs::OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(TEMP_SCRIPT_PATH)
            .unwrap();

        let script = format!(
            "# This file is automatically @generated by {}.\n# It is not intended for manual editing.\n\n{}\n",
            clap::crate_name!(),
            cmd_list.join("\n")
        );

        sh.write_all(script.as_bytes())?;
        sh.flush()?;

        run_cmd!(chmod +x $TEMP_SCRIPT_PATH)?;

        let stdout = run_fun!(sh $TEMP_SCRIPT_PATH)?;

        Ok(stdout)
    }

    fn compile_run_str(&self, ctx: Context) -> Result<Vec<String>> {
        let mut result = vec![];

        if self.run.is_none() {
            return Ok(result);
        }

        for line in self.run.as_ref().unwrap().lines() {
            if line.is_empty() {
                continue;
            }

            if line.starts_with('#') {
                result.push(line.to_string());
                continue;
            }

            let template = Template::new();
            let rendered = template.render(line, &ctx);

            result.push(rendered);
        }

        Ok(result)
    }
}

pub struct Matcher {
    pub header: Option<Yaml>,
    pub body: Option<Yaml>,
}

#[test]
fn test_config() {
    let config = Config::from_file("test/fixtures/config.yml").unwrap();
    let req = Request::default();
    let body: Value = serde_json::from_str(include_str!("../test/fixtures/body.json")).unwrap();
    let secrets: Value = serde_json::from_str(r#"{ "SOME_TOKEN": "token" }"#).unwrap();

    let rule = config.try_match(&req, &body);
    assert!(rule.is_some());

    let ctx = Context {
        body: Some(&body),
        secrets: Some(&secrets),
    };

    let stdout = rule.unwrap().run(ctx).unwrap();
    assert_eq!(stdout, "release name: v1.0.0-alpha.0\nsome secret token: token")
}
