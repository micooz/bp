use crate::constants::{TEMP_DIR, TEMP_SCRIPT_PATH};
use crate::context::Context;
use crate::utils::template::Template;
use crate::utils::yaml_checker::YamlChecker;
use anyhow::{Error, Result};
use cmd_lib::{run_cmd, run_fun};
use serde_json::Value;
use std::fs;
use std::io::Read;
use std::io::Write;
use std::path::Path;
use yaml_rust::Yaml;
use yaml_rust::YamlLoader;

pub struct Config {
    rules: Vec<Rule>,
}

impl Config {
    pub fn from_file<P>(file: P) -> Result<Self>
    where
        P: AsRef<Path>,
    {
        let mut yaml_file = fs::OpenOptions::new().read(true).open(file)?;
        let mut yaml_content = String::new();

        yaml_file.read_to_string(&mut yaml_content)?;

        let doc = &YamlLoader::load_from_str(yaml_content.as_str()).unwrap()[0];
        let doc = doc.as_hash().ok_or_else(|| Error::msg("invalid yaml format"))?;

        let mut rules = vec![];

        for item in doc.values() {
            let rule = Rule::from_yaml_doc(item.clone()).map_err(|_| Error::msg("invalid yaml format"))?;
            rules.push(rule);
        }

        Ok(Self { rules })
    }

    pub fn try_match(&self, payload: &Value) -> Option<&Rule> {
        for rule in &self.rules {
            if rule.try_match(payload).is_ok() {
                return Some(rule);
            }
        }
        None
    }
}

pub struct Rule {
    match_pattern: Yaml,
    run_cmd: String,
}

impl Rule {
    pub fn from_yaml_doc(doc: Yaml) -> Result<Self, ()> {
        let root = doc.as_hash().ok_or(())?;

        // get "match: xxx"
        let match_pattern = root.get(&Yaml::String("match".to_string())).ok_or(())?;

        // get "run: xxx"
        let run_cmd = root.get(&Yaml::String("run".to_string())).ok_or(())?;
        let run_cmd = run_cmd.as_str().ok_or(())?;

        Ok(Rule {
            match_pattern: match_pattern.clone(),
            run_cmd: run_cmd.to_string(),
        })
    }

    pub fn try_match(&self, json: &Value) -> Result<(), ()> {
        let checker = YamlChecker::new();

        if checker.check_json(&self.match_pattern, json) {
            Ok(())
        } else {
            Err(())
        }
    }

    pub fn run(&self, ctx: Context) -> Result<String> {
        let cmd_list = self.compile_run_str(ctx)?;

        run_cmd!(mkdir -p $TEMP_DIR)?;

        let mut sh = fs::OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(TEMP_SCRIPT_PATH)
            .unwrap();

        let script = format!(
            "# This file is automatically @generated by {}.\n# It is not intended for manual editing.\n\n{}\n",
            clap::crate_name!(),
            cmd_list.join("\n")
        );

        sh.write_all(script.as_bytes())?;
        sh.flush()?;

        run_cmd!(chmod +x $TEMP_SCRIPT_PATH)?;

        let stdout = run_fun!(sh $TEMP_SCRIPT_PATH)?;

        Ok(stdout)
    }

    fn compile_run_str(&self, ctx: Context) -> Result<Vec<String>> {
        let mut result = vec![];

        for line in self.run_cmd.lines() {
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            let template = Template::new();
            let rendered = template.render(line, &ctx);

            result.push(rendered);
        }

        Ok(result)
    }
}

#[test]
fn test_config() {
    let config = Config::from_file("test/fixtures/config.yml").unwrap();
    let json: Value = serde_json::from_str(include_str!("../test/fixtures/payload.json")).unwrap();
    let secrets: Value = serde_json::from_str(r#"{ "SOME_TOKEN": "token" }"#).unwrap();

    let rule = config.try_match(&json);
    assert!(rule.is_some());

    let ctx = Context {
        data: Some(&json),
        secrets: Some(&secrets),
    };

    let stdout = rule.unwrap().run(ctx).unwrap();
    assert_eq!(stdout, "release name: v1.0.0-alpha.0\nsome secret token: token")
}
